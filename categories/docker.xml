<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Karl Lorey (Posts about Docker)</title><link>https://karllorey.com/</link><description></description><atom:link type="application/rss+xml" rel="self" href="https://karllorey.com/categories/docker.xml"></atom:link><language>en</language><copyright>Contents Â© 2020 &lt;a href="mailto:hello@karllorey.com"&gt;Karl Lorey&lt;/a&gt; </copyright><lastBuildDate>Wed, 26 Feb 2020 15:26:33 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Django in Production with mod_wsgi and Docker</title><link>https://karllorey.com/posts/django-production-docker-mod-wsgi/</link><dc:creator>Karl Lorey</dc:creator><description>&lt;div&gt;&lt;p&gt;This article will show you how to run Django in production with docker and apache2/mod_wsgi.
While there are several guides on how to do it,
I found no simple enough tutorial on how to do it
since all of the existing solutions require a lot of configuration or a custom docker image.
The solution I found is way quicker and requires close to no configuration.&lt;/p&gt;
&lt;p&gt;Guides I found:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.djangoproject.com/en/3.0/howto/deployment/wsgi/modwsgi/"&gt;Django with Apache and mod_wsgi&lt;/a&gt; assumes you have installed everything already and requires configuration possibly unnecessary for a dockerized version&lt;/li&gt;
&lt;li&gt;&lt;a href="https://modwsgi.readthedocs.io/en/develop/"&gt;mod_wsgi&lt;/a&gt; explains how to install mod_wsgi, but not how to use Django with it&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, let's do this.
If you just want to see the final Dockerfile, scroll to the end of the article :)&lt;/p&gt;
&lt;h3&gt;Prerequisites&lt;/h3&gt;
&lt;p&gt;I assume you have some Dockerfile with Django application setup
and run Django via the command that spins up the development server:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;python:3.6&lt;/span&gt;

&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; /code/&lt;/span&gt;

&lt;span class="c"&gt;# copy and install requirements first to leverage caching&lt;/span&gt;
&lt;span class="k"&gt;COPY&lt;/span&gt; requirements.txt /code/
&lt;span class="k"&gt;RUN&lt;/span&gt; pip install -r requirements.txt

&lt;span class="c"&gt;# copy the actual code&lt;/span&gt;
&lt;span class="k"&gt;COPY&lt;/span&gt; . /code/

&lt;span class="k"&gt;CMD&lt;/span&gt; ./manage.py runserver &lt;span class="m"&gt;0&lt;/span&gt;.0.0.0:8000
&lt;/code&gt;&lt;/pre&gt;


&lt;h3&gt;Step 1: Install Apache&lt;/h3&gt;
&lt;p&gt;We basically need a working Apache setup to run python code via mod_wsgi.
So in our Dockerfile, we need to install apache2 and apache2-dev.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get install apache2 apache2-dev
&lt;/code&gt;&lt;/pre&gt;


&lt;h3&gt;Step 2: install mod_wsgi&lt;/h3&gt;
&lt;p&gt;We want to run our project within a container.
The mod_wsgi documentation says the easiest and preferred using docker
is to use mod_wsgi-express as it does not require any configuration.
mod_wsgi-express can be used as a command after you have installed it via pip.
So we need to add:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; pip install mod_wsgi
&lt;/code&gt;&lt;/pre&gt;


&lt;h3&gt;Step 3: run Django inside Apache with mod_wsgi&lt;/h3&gt;
&lt;p&gt;Lastly, we simply have to run mod_wsgi-express
which will start an apache instance with our Django project.
This can be achieved via:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mod_wsgi-express start-server /code/project_name/wsgi.py --user www-data --group www-data
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The wsgi.py file is auto-generated by Django's &lt;code&gt;startproject&lt;/code&gt; command and inside you app's folder,
i.e. &lt;code&gt;django-project/project_name&lt;/code&gt;.
So, to run our project within Apache after we've set-up everything in the Dockerfile,
we have to add a &lt;code&gt;CMD&lt;/code&gt; command at the end of the Dockerfile:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;CMD&lt;/span&gt; mod_wsgi-express start-server /code/connect_web/wsgi.py --user www-data --group www-data
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;--user&lt;/code&gt; and &lt;code&gt;--group&lt;/code&gt; parameters make sure Apache isn't run as root which results in errors.
If you want to find out, just run the command without them.&lt;/p&gt;
&lt;h3&gt;Final Dockerfile: Installing and running Apache and mod_wsgi within Docker&lt;/h3&gt;
&lt;p&gt;Your final Dockerfile should now look like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;python:3.6&lt;/span&gt;

&lt;span class="c"&gt;# update packages&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get -qq update
&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get install --yes apache2 apache2-dev
&lt;span class="k"&gt;RUN&lt;/span&gt; pip install mod_wsgi

&lt;span class="k"&gt;RUN&lt;/span&gt; mkdir /code
&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; /code&lt;/span&gt;

&lt;span class="k"&gt;COPY&lt;/span&gt; . /code/

&lt;span class="k"&gt;CMD&lt;/span&gt; mod_wsgi-express start-server /code/project_name/wsgi.py --user www-data --group www-data
&lt;/code&gt;&lt;/pre&gt;


&lt;h3&gt;Troubleshooting&lt;/h3&gt;
&lt;p&gt;If you have any problems, check the logs. Their locations are outputted when starting the container:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;web_1     | Server URL         : http://localhost:8000/
web_1     | Server Root        : /tmp/mod_wsgi-localhost:8000:0
web_1     | Server Conf        : /tmp/mod_wsgi-localhost:8000:0/httpd.conf
web_1     | Error Log File     : /tmp/mod_wsgi-localhost:8000:0/error_log (warn)
web_1     | Request Capacity   : 5 (1 process * 5 threads)
web_1     | Request Timeout    : 60 (seconds)
web_1     | Startup Timeout    : 15 (seconds)
web_1     | Queue Backlog      : 100 (connections)
web_1     | Queue Timeout      : 45 (seconds)
web_1     | Server Capacity    : 20 (event/worker), 20 (prefork)
web_1     | Server Backlog     : 500 (connections)
web_1     | Locale Setting     : en_US.UTF-8
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;If you want to monitor them, just &lt;code&gt;tail -f&lt;/code&gt; them:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tail -f /tmp/mod_wsgi-localhost:8000:0/error_log
&lt;/code&gt;&lt;/pre&gt;


&lt;h4&gt;Permission problems&lt;/h4&gt;
&lt;p&gt;At first, I got an &lt;code&gt;Internal Server Error&lt;/code&gt; when opening the page on my machine.
After checking the logs as described above, mod_wsgi seemed to have problems with file permissions on &lt;code&gt;.logs/debug.log&lt;/code&gt;.
A simple &lt;code&gt;chown www-data /code/.logs/debug.log&lt;/code&gt; from within the container
which makes www-data the owner of the file solved it for me.&lt;/p&gt;&lt;/div&gt;</description><category>Django</category><category>Docker</category><category>Python</category><category>Tech</category><guid>https://karllorey.com/posts/django-production-docker-mod-wsgi/</guid><pubDate>Fri, 17 Jan 2020 09:30:13 GMT</pubDate></item><item><title>How to set up Black with Debian, PyCharm, and IdeaVim</title><link>https://karllorey.com/posts/set-up-black-pycharm-ideavim/</link><dc:creator>Karl Lorey</dc:creator><description>&lt;div&gt;&lt;p&gt;I've come to like the code formatter &lt;a href="https://black.readthedocs.io/en/stable/index.html"&gt;Black&lt;/a&gt; for Python.
It's opinionated, deterministic and thus very minimalistic.
And since I'm using it on more and more projects, I wanted to integrate it into my workflow.&lt;/p&gt;
&lt;p&gt;So usually, you just install Black globally via &lt;code&gt;pip3 install black&lt;/code&gt;.
But since I use Debian which still ships with Python 3.5
this yielded some smaller challenges as Black only runs under Python 3.6+.
This post is a small tutorial on how you can use Black on Debian and integrate it into the command line, PyCharm, and IdeaVim.&lt;/p&gt;
&lt;h3&gt;Challenge 1: Python 3.6+ on Debian&lt;/h3&gt;
&lt;p&gt;Since Debian currently ships with Python 3.5, I needed to get Python 3.6 running somehow.
While installing &lt;a href="https://www.anaconda.com/distribution/"&gt;Anaconda&lt;/a&gt; or &lt;a href="https://www.python.org/downloads/"&gt;Python 3.6+ manually&lt;/a&gt;
are other solutions &lt;a href="https://community.hortonworks.com/idea/212478/independent-python-vs-anaconda-python.html"&gt;might&lt;/a&gt; &lt;a href="https://unix.stackexchange.com/q/332641"&gt;work&lt;/a&gt;,
I decided to simply use Docker, as this is what I use for my regular development anyhow.
Simplest solution was to use an existing docker image,
namely &lt;a href="https://github.com/jbbarth/docker-black"&gt;jbbarth's docker-black&lt;/a&gt;,
which allows you to mount the current working directory into a (newly created) container, format the desired file, and throw the container away afterwards.
Sounds more complicated than it is, you just run one single command et voila.
This method has the additional benefit that it adheres to any &lt;a href="https://github.com/psf/black#pyprojecttoml"&gt;pyproject.toml&lt;/a&gt; which can store configuration like line length.
There's also a more sleek image at &lt;a href="https://github.com/cytopia/docker-black"&gt;cytopia/docker-black&lt;/a&gt; which might take less space.&lt;/p&gt;
&lt;p&gt;So to run black irrespective of your local Python installation via &lt;code&gt;black main.py&lt;/code&gt;,
you run&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;docker run --rm -v $(pwd):/code jbbarth/black main.py
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;This creates a new container, mounts the current working directory into &lt;code&gt;/code&lt;/code&gt; and formats &lt;code&gt;main.py&lt;/code&gt;.
Afterwards, the &lt;code&gt;--rm&lt;/code&gt; flag will delete the container as well as the created volume.
So far, so good, but as this command is quote long, I had to build an alias to invoke it quickly as a next step.&lt;/p&gt;
&lt;h3&gt;Challenge 2: Black from command line&lt;/h3&gt;
&lt;p&gt;So to avoid the cumbersome docker syntax each time, you now want an alias to just run &lt;code&gt;black main.py&lt;/code&gt; everywhere.
To do this, you have to map the black command to your black running inside docker.
You can do this by adding&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;black() { docker run --rm -v $(pwd):/code jbbarth/black $*; }
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;to your bashrc or zshrc.
After opening a new terminal, you should now be able to invoke the black formatter inside docker by running &lt;code&gt;black ...&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Challenge 3: Black in PyCharm&lt;/h3&gt;
&lt;p&gt;To now integrate this setup into PyCharm,
you have to slightly adapt the &lt;a href="https://black.readthedocs.io/en/stable/editor_integration.html#pycharm-intellij-idea"&gt;offical installation instructions&lt;/a&gt;.
Go to &lt;code&gt;File -&amp;gt; Settings -&amp;gt; Tools -&amp;gt; External Tools&lt;/code&gt;.
Click the + icon to add a new external tool with the following values:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Name: &lt;code&gt;Black&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Description: &lt;code&gt;Black code formatter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Program: &lt;code&gt;/usr/bin/docker&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Arguments: &lt;code&gt;run --rm -v $FilePath$:/$FilePath$ jbbarth/black "$FilePath$"&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Working directory: &lt;code&gt;$ProjectFileDir$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Test it by running it with an opened python file via &lt;code&gt;Tools -&amp;gt; External Tools -&amp;gt; Black&lt;/code&gt;.
After you made sure it works, re-open it again and untick &lt;code&gt;open console&lt;/code&gt; to avoid a new console at every run.
You can basically mirror this guide to install a file watcher
that formats on every save (see &lt;a href="https://black.readthedocs.io/en/stable/editor_integration.html#pycharm-intellij-idea"&gt;the docs&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Note: As you can see, this only mounts the current file and thus does not adhere to any config files.
The same applies for the next step as it builds upon this one.&lt;/p&gt;
&lt;h3&gt;Challenge 4: Black in IdeaVim&lt;/h3&gt;
&lt;p&gt;Now for the bonus part: to trigger this setup quickly from within IdeaVim and format the current file with a single command,
equivalent to the &lt;a href="https://black.readthedocs.io/en/stable/editor_integration.html#vim"&gt;regular vim plugin&lt;/a&gt;,
we have to map the &lt;code&gt;:Black&lt;/code&gt; command to our external command in PyCharm.
To do this, we edit our &lt;code&gt;.ideavimrc&lt;/code&gt; file where all IdeaVim configuration is stored,
and add the following line:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;command Black action Tool_External Tools_Black
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Now typing &lt;code&gt;:Black&lt;/code&gt; will re-format the current file.&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;This tutorial showed you one way to include Black into you daily development (esp. on Debian).
If you have any questions or feedback, hit me up on Twitter &lt;a href="https://twitter.com/karllorey"&gt;@karllorey&lt;/a&gt;
or any of the other platforms listed below.&lt;/p&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;h4&gt;Deleting all docker containers of a specific image&lt;/h4&gt;
&lt;p&gt;If you want to remove all containers derived from a specific image, e.g. if you forgot to add the --rm flag:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;docker rm $(docker ps -a --filter ancestor=jbbarth/black -q)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>Black</category><category>Docker</category><category>IdeaVim</category><category>Pycharm</category><category>Python</category><category>Tech</category><guid>https://karllorey.com/posts/set-up-black-pycharm-ideavim/</guid><pubDate>Sun, 28 Jul 2019 09:30:13 GMT</pubDate></item></channel></rss>